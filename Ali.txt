C罗的自律视频
https://www.youtube.com/watch?v=dcHFQjW-R1g

mac操作系统相关
command+shift+3，截取整个屏幕，保存图片在桌面。
command+shift+4，任意截取部分屏幕，保存图片在桌面。
command+shift+4+最后按空格，截取某个窗口的内容，保存图片在桌面。

=================================================================================================

常用sql总结
环境：在iDB 4.0网页版中。

列出某一张表的所有的字段以及字段的设置信息：
desc delta_dataset_content
左连接：
左边表中的数据都会出现，即使在右边表中没有相应的记录。

=================================================================================================
debug不能进入代码断点排查：

1，打开开发者工具，看这个接口的域名和“Remote Address”的内容是什么；
2，看ihost里面配置的域名和ip是不是和开发者工具里面的一致；
3，看http://proxy.alibaba-inc.com/index.do里面配置的utcp配置的服务器的ip到底是哪一台机器，是66还是238！


=================================================================================================
git命令汇总

github
skywalker2233
18280482470zxc12

git reset --hard 276ece3

git pull origin master

git push -u origin master

git add -A

git commit -m "need you to discribe what you have done in project during this commit"

git push


git拉分支命令
注意修改“feature”后面的内容！！！
git clone  http://gitlab.alibaba-inc.com/utcp/utcp-admin.git -b feature/20180517_2263036_optimize_1  "D:/work/feature/20180517_2263036_optimize_1"

=================================================================================================
投放系统关键环节：

导入选品集，并确定字段映射关系；

保存排期数据到数据库中；

scheduleX抓取一个执行时间已到的排期进行执行；

执行排期里面设定好的规则（数据准备，赛马排序，去重，各种过滤，生成PublishJob）

推送数据到oss

=================================================================================================
字段映射环节梳理：

三个环节：

一，点击“绑定数据”按钮->跳出“选品导入”页面，字段映射关系首先分为是“历史记录”（最近一次选择的选品集生成的字段映射关系）里面的字段映射关系 or 没有历史记录 or 当操作者主动选择一个选品集（该api会再次被调用，但逻辑与前面不同，是有选品集id的。）。

二，根据选品集的类型是“素材中心”or“招商类型”，展现类型是赛马or 个性化，分别进行处理；

三，根据前面分流的结果，本环节，只查询某个字段应该映射的是什么字段。<K, <K, V>>（第一个K为前端需要的字段名字，第二个K为映射好的字段的名字，V为最终展示在页面上的字段的内容），根据V获取的方式不同，分为规则写入（到其他标准数据源，动态查询获取V） or 非规则写入（到数据库中获取V）；

-------------------------------------------------------------------------------------------------

->点击“绑定数据”按钮->跳出“选品导入”页面。
1，
函数功能：返回“字段映射关系”中的前端页面需要哪些字段，保存在result.filedMappingList这个数组里面。每一个需要填入数据的字段的名字为K，V呢，需要从result.exportedColumnList里面进行选择，选择K合适的对应的 V。一个例子：[标题背景图，主标题，副标题，标题外部链接]。对于“标题背景图”这个K的V，可以从result.exportedColumnList里面进行选择，result.exportedColumnList的一个例子：[商品图片，商品利益点，商品标题，预售活动价格标题，大额优惠券状态，…]等等，非常多的可选择的V。
public void ImportDataNew.queryFieldMappingInfo(TurbineRunData rundata, Context context) {
从TurbineRunData中获取inputType；
如果是3（个性化）{
    那么：1.1，queryFieldMappingInfo4UplusPersonal(rundata, context);
}
如果是4(标准数据源){
    那么：1.2，queryFieldMappingInfo4UdcDataSource(rundata, context);
}
其他（赛马/轮播）{
    1.3，queryFieldMappingInfo4OldNew(rundata, context);
}
}
-------------------------------------------------------------------------------------------------
1.2,
函数功能：人工静态数据的导入（inputType没有输入值）
private void queryFieldMappingInfo4UdcDataSource(TurbineRunData rundata, Context context) {
行506-510，从rundata里面取一些必要的数据：datasetId；
行515，根据datasetId取DeltaDatasetDO对象，调用：DeltaDatasetDO datasetDO = datasetAO.getDatasetById(datasetId);
行528-516，从DeltaDatasetDO对象里面取出一些必要的数据；
行542，如果(udcDataSourceInstanceId!=null&&udcDataSourceInstanceId>0){
那么，行543,根据udcDataSourceInstanceId查询出UdcDataSourceInstanceDO对象，
如果（udcDataSourceInstanceDO对象!=null && udcDataSourceId==0）{
行547，从UdcDataSourceInstanceDO对象中取出paramsJson字段；
行555，将paramsJson解析为List，将list中每个元素中的key，value存于UdcDataSourceMapperVO对象中；
}
设置返回字段映射,
}
行566，活动所有的dataSourceList：
行567-行572，新建一个Map，放入3个查询条件，都是写死的<K,V>；
行575，根据查询条件得到查询结果dsResult；
行576-行588，将查询结果转换为List<UdcDataSourceDO>；
行591，根据udcDataSourceId查询UdcDataSourceDO对象；
行592-行599，遍历List<UdcDataSourceDO>，将每个元素中的一些字段保存到UdcDataSourceMapperVO对象中；
行600，//XField字段构建 直接从udcDataSource中获取参数字段 和参数形式；
行602-行606，根据udcDataSourceId查询，如果能查询成功，得到DataSourceVO对象；
行609，如果(DataSourceVO对象!=null){
    如果(udcDataSourceDO == null){
        从DataSourceVO对象里面取必要的数据；
    } else {
从udcDataSourceDO对象里面取必要的数据：     List<UdcSourceParamsVO> paramsVOS和List<Map<String,String>> dataSourceColumnList；
    }
    遍历List<UdcSourceParamsVO> paramsVOS{
取出每个元素的一些字段，保存到UdcDataSourceMapperVO vo对      象的xField字段中；
如果(UdcDataSourceMapperVO vo对象的getParamValue()f返回空){
    从每个UdcSourceParamsVO元素中取出默认值填进去；
}
}
行666，如果resourceId不为空，那么，根据resourceId查询RmcResourceDO       对象；接着获取resourceCode；
行677，根据entityType(baomingType)查询List<Map<String,String>> systemColumnList
行683-行688，将systemColumnList和dataSourceColumnList都保存到UdcDataSourceMapperVO vo中，
行690-行692，根据从DeltaDatasetDO对象中的templateId，获取并解析List<FieldMappingDO>，保存到UdcDataSourceMapperVO vo中；
行703，将vo保存到UiResultSupport uiResult；
行708，返回UiResultSupport uiResult；
}
-------------------------------------------------------------------------------------------------
1.3，
函数功能：
    赛马部分的字段映射
private void 	ImportDataNew.queryFieldMappingInfo4OldNew(TurbineRunData rundata, Context context) {
行1076-行1084，从rundata里面取必要的数据：uplusSceneId,选品集id，取不到赋值为0L；baomingId，取不到时就会赋值为0L；
行1087-行1095，根据resourceId查询resourceCode；
行1096，根据datasetId查询得到DeltaDatasetDO datasetDO对象；
行1107，根据datasetId查询历史最后一次选择的选品集，并导入字段的匹配关系，调用：DeltaDatasetImportNewDO importNewDo = deltaDatasetImportManager.findLastBaomingImportByDatasetId(datasetId);
行1110-行1132，优先取高级投放的；如果(baomingId ==0L){
    如果（DeltaDatasetImportNewDO importNewDo==null）{
根据resourceCode再取一次DeltaDatasetImportNewDO   importNewDo；
从importNewDo对象里面取出baomingId，activityId，entityType，uplusId，根据uplusId取UplusSceneDO，再取出uplusName；
    }
}
行1134-行1151：取个性化数据源的；如果(baomingId ==0L){
    行1135，根据datasetId取DeltaDatasetDO deltaDatasetDO对象；
    行1136-行1146，根据deltaDatasetDO对象来填充baomingId；
}
行1152-行1157，填充activityId；
行1161-行1179，填充查询条件到FieldMappingParamSO paramSO对象中，
行1180，根据paramSO对象查询得到FieldMappingInfoSO infoSO对象，从查询得到的infoSO对象中，得到要返回的数据，取出来保存到FieldMappingInfo mappingInfos对象中，
行1184-行1192，保存数据到FieldMappingInfo mappingInfos中；
行1203，返回数据；
}

-------------------------------------------------------------------------------------------------
1.3，
优化后的接口：
函数功能：
    赛马部分的字段映射
private void 	ImportDataNew.queryFieldMappingInfo4OldNew(TurbineRunData rundata, Context context) {
行834-行843，从rundata里面取必要的数据：uplusSceneId,选品集id，取不到赋值为0L；
行875，如果uplusSceneId == 0L，没从前端拿到数据，那就从历史里面查询，importNewDo = deltaDatasetImportManager.getLastBaomingImportByResourceCode(resourceCode);从查询结果中得到uplusSceneId；
行 932，如果uplusSceneId已经有值了（即：从历史中查询得到选品集或者操作者手动选择一个选品集），那么{
行933-行955，设置paramSO；
行956，调用1.3.1，FieldMappingInfoSO infoSO = fieldMappingAO.queryFieldMappingList(paramSO);
} else，即：没有历史记录{
    什么也不展示；
}

}
-------------------------------------------------------------------------------------------------------
1.3.1，
public FieldMappingInfoSO FieldMappingAOImpl.queryFieldMappingList(FieldMappingParamSO fieldMappingParamSO) {
行171-行198，区分选品集的类型：目前只有两种类型：招商或者素材中心；
行201-行215，根据展现形式是赛马or个性化；根据选品集的类型是招商or素材中心，分别进行处理；
如果是赛马 && 招商类型，调用1.3.1.1，FieldMappingAOImpl.queryMerchantsFieldMappingListForHorseRace();
}
-------------------------------------------------------------------------------------------------
1.3.1.1，
private FieldMappingInfoSO FieldMappingAOImpl.queryMerchantsFieldMappingListForHorseRace(FieldMappingParamSO fieldMappingParamSO) {
行288，获取系统来源的字段的列表；
行289，获取外部报名来源的字段的列表；
行291-行297，List<Map<String, String>> exportedColumnList表示可以供运营候选的字段的集合；将系统来源的字段集合和外部报名来源的字段的集合都添加到exportedColumnList里面；
行316，完成运营搭建的这个模块的前端需要展示的字段（K）的映射的字段（V）的自动映射工作；调用1.3.1.1.1，List<FieldMappingDO> fieldMappingList = unifyFieldMappingAO.autoMerchantsFieldMappingForHorceRace(unifyParamSO);
行322-行326，fieldMappingList，exportedColumnList保存到返回值中；
}
-------------------------------------------------------------------------------------------------
1.3.1.1.1，
public List<FieldMappingDO> autoMerchantsFieldMappingForHorceRace(FieldMappingUnifyParamSO paramSO) {
    只是调用下面的方法；
}
private List<FieldMappingDO> UnifyFieldMappingAOImpl.defaultHorseRaceFieldMapping(FieldMappingUnifyParamSO paramSO) {
行96，获取前端需要展现的字段的名字和字段的数据类型（例子：ItemDiscripition->String;ItemUrl商品链接->url）,调用1.3.1.1.1.1，List<DeltaDatasetMetaMappingDO> metaMappingList = this.deltaDatasetMetaMappingManager.queryDatasetMetaMappingsByDatasetId(paramSO.getDatasetId());
行130-行134，判断是“规则写入”（动态查询）or“非规则写入”（数据库）；
如果是规则写入{
} else{
    调用1.3.1.1.1.2，matched = processDBField(paramSO, fieldMappingList, lockFieldSwitch, metaMapping);
}
}

-------------------------------------------------------------------------------------------------------
1.3.1.1.1.1，
函数功能：获取前端需要展现的字段的名字和字段的数据类型；
List<DeltaDatasetMetaMappingDO> metaMappingList = UnifyFieldMappingAOImpl.
deltaDatasetMetaMappingManager.queryDatasetMetaMappingsByDatasetId(paramSO.getDatasetId()){

}
-------------------------------------------------------------------------------------------------------
1.3.1.1.1.2，
函数功能：完成某个字段的自动映射的功能；
public boolean UnifyFieldMappingAOImpl .processDBField(FieldMappingUnifyParamSO paramSO, List<FieldMappingDO> fieldMappingList, boolean lockFieldSwitch, final DeltaDatasetMetaMappingDO metaMapping) {
行392，查找某个字段的应该映射的那个字段，调用，final ConstantDO constantDO = this.constantAO.findConstantDOByValue(rwFieldCode, getConstCode(entityCode));
行410，映射成功，新建这个映射对象<前端需要的字段，映射的字段>；
行436，从系统候选字段集合里面去查询字段映射关系，调用，fielMapping = this.findSystemFieldForTmsField(metaMapping, paramSO.getSystemColumnList());
}
-------------------------------------------------------------------------------------------------



=================================================================================================

保存一个排期的相关数据到数据库中的过程。

3，
点击“发布”按钮。
函数功能：
    保存一个排期的相关数据，到表中<delta_page_publish_job>。（注意，和排期到指定执行时刻，"开始执行排期"有本质的不同）
public ResultDO<?> UtcpScheduleService.publish (BaseRequest request) {
    行1065-行1069，从输入参数中拿出scheduleInfo，并转换为ScheduleDO对象；
    行1070，从ScheduleDO对象中获取inputType；
    行1074，3.1，？？？，调用：utcpScheduleGenerator.publish(scheduleDO, publishResult, DeltaDatasetDO.InputTypeEnum.getValue(inputType));
    行1083，3.2，？？？根据datasetId取dataset对象，调用DeltaDatasetDO dataset = deltaDatasetManagerV2.findDeltaDatasetById(dRule.getDatasetId());
    行1084，填充data对象，保存到返回值中；调用，3.3，getDataMap(dRule, data, dataset);
}
-------------------------------------------------------------------------------------------------
3.1，
函数功能：

public void UtcpScheduleGenerator.publish(final ScheduleDO scheduleDO, final ResultDO<DeltaRuleDO> result,                       final InputTypeEnum inputType) {
    行1154，调用3.1.1，UtcpScheduleGenerator.publish
}
-------------------------------------------------------------------------------------------------
3.1.1，
函数功能：
public void UtcpScheduleGenerator.publish(final ScheduleDO scheduleDO, final DataContentVO dataContentVO,                       final ResultDO<DeltaRuleDO> result, final InputTypeEnum inputType) {
    行847-行859，取排期RuleDO对象；调用3.1.1.0，getDeltaRuleInfo
    行868，校验排期，调用3.1.1.1，deltaRuleManagerV2.validateRule(ruleDO);
    行877，根据ruleDO对象中的datasetId查询DeltaDataset对象；
    行891，从DeltaDataset对象中，取出DeltaDatasetAttr对象；
    行895，如果是“个性化”{
        行912，根据uplusSceneId查询UplusSceneDO对象（描述运营配置的数据场景，包括数据集，排期，投放等相关信息配置）；
        行913，将一些配置信息保存到UplusSceneDO对象中；调用：3.1.1.1，deltaDatasetManagerV2.buildDataSourceConfig(uplusSceneDO, dataset, datasetAttr, category, fieldColumnMapping, uplusList);
        行921-行925，如果newUplusIdSet中不包含这个id，那么就从dataSourceConfigMap中删除掉。
    }
    行944，如果是“？？？类型4”{
    
	}
    行1006，如果是“赛马”{
    行1007，检查必填字段(*标注)有没有填写数据，调用：3.1.1.2，boolean success = deltaDatasetContentTempManagerV2.verifyRequiredField(dataset);
    }
    行1013-行1022，获取activityId的值，设置到dataset中；
    行1023-行1026，更新RmcResource的一行记录的“流程模板”字段的值；
    行1027-行1030，更新RmcResource的一行记录的“个性化推荐扩充参数”字段的值；
    行1031，根据业务场景，生成流程代码。调用3.1.1.3，datasetAttr = initWorkflowAttr(inputType.getCodeValue(), entityType, ruleDO, dataset, datasetAttr, needNewDelyId,dsc_ModuleId);
    行1034-行1038，更新或者新增DeltaRuleDO对象到数据库里面；
    行1039，更新或者插入DeltaRuleSchedule，更新DeltaDatasetDO，调用，3.1.1.4，updateScheduleInfo(ruleDO,dataset);
    行1061，？？？，调用3.1.1.5，deltaRuleAO.finishRuleInfo(ruleDO, ruleDO.getId(), reSort, conditionParams);
	行1062，？？？，3.1.1.6，涉及到临时表和正式表的保存操作。调用：com.alibaba.biz.command.result.Result subResult = datasetAOImplV2.subTemp(ruleDO.getDatasetId(), false);
	行1072，？？？，发布商品的时候通知竞品，调用，notifyOnlineMsg(ruleDO);
    行1079，提交页面发布任务，调用3.1.1.7，this.pagePublishJobProducer.commitPagePublishJob(pageId, DeltaAdminEnv.getEnv(), creator);
}
-------------------------------------------------------------------------------------------------
3.1.1.0，
函数功能：从页面获取规则数据
public DeltaRuleDO UtcpScheduleGenerator.getDeltaRuleInfo(ScheduleDO scheduleDO, DataContentVO dataContentVO,
                                        InputTypeEnum inputType) throws Exception {
    行266-行270，检查资源位是否存在；
    行271-行280，检查页面是否存在，是否下线；
    如果是静态{}
    else{
        从scheduleDO里面拿出必要的数据；ruleId
    }
    行311-行383，根据ruleId查询DeltaRuleDO，进而构建DeltaRule对象；用于返回；

    
}

-------------------------------------------------------------------------------------------------

3.1.1.6，
函数功能：
public Result DatasetAOImplV2.subTemp(final Long dataSetId, boolean verifyEntity) {
行361，如果是个性化，那么，更新DeltaDatasetDO对象的status字段；
行367-行372，根据datasetId到表<delta_dataset_content_temp>中查询，调用3.1.1.6.1：List<DeltaDatasetContentDO> untempList = deltaDatasetContentTempManagerV2.findContentTempByList(deltaDatasetContentQuery);
行379，验证数据是否合法 && 补全数据信息，调用3.1.1.6.2：final List<DeltaDatasetContentDO> tempList = validExistence(untempList, verifyEntity);
行386，根据datasetId到正式表<delta_dataset_content> 中删除记录；
行389，将临时表<delta_dataset_content_temp>中记录（tempList）拷贝到正式表<delta_dataset_content>
}
-------------------------------------------------------------------------------------------------
3.1.1.7，
函数功能：提交页面发布任务
public boolean commitPagePublishJob(String pageId, final String ownSign, final String creator) {
    行147，在数据库里面插入数据，调用，this.deltaPagePublishJobDAO.insertDeltaPagePublishJob(deltaPagePublishJobDO );
}
-------------------------------------------------------------------------------------------------

3.1.1.6.2，
函数功能：对提交到正式表中的数据验证是否合法 && 补全数据信息
public List<DeltaDatasetContentDO> DatasetAOImplV2.validExistence(List<DeltaDatasetContentDO> untempList, boolean verifyEntity) {
行424-行431，查询表<delta_constant>，如果值为true，那么，将输入参数untempList保存到finalTempList里面，（直接返回了）
行440，如果不需要校验数据，那么，调用3.1.1.6.2.1，buildEntity(temp, datasetId2PageIdMap); untempList逐个元素保存到finalTempList里面，（后续直接返回了）；
行443，如果需要校验数据，那么{
行444，如果temp的实体类型是商品，那么{
行450，根据商品id查询商品；如果可以找到这个商品，那么，补全字段；
行453，调用3.1.1.6.2.1：buildEntity(temp, datasetId2PageIdMap);
}
如果temp的实体类型是店铺，那么{
    店铺类型只做校验（查询卖家id是否存在）不做补全；
}

    如果temp的实体类型是lazada商品，那么{}

}
}
-------------------------------------------------------------------------------------------------
3.1.1.6.2.1，
函数功能：补全字段
private void DatasetAOImplV2.buildEntity(DeltaDatasetContentDO temp, Map<Long, String> datasetId2PageIdMap) {
行548，查询datasetId对应的pageId（datasetId->DeltaTemplateDO->resourceCode->pageId）；

}

-------------------------------------------------------------------------------------------------

=================================================================================================

投放系统后台业务主要环节：
一，抓取任务
所有的任务都放于<delta_page_publish_job>表中。表的重要字段id| page_id（页面id，以页面为单位抓取任务。但是同样的page_id可能被多次提交到这张表里面）|status（0：未执行。3：执行中。1执行成功。2，执行异常。）|own_sign|version（时间戳版本号，加锁用）|

抓取任务的大前提：多台机器去抓取任务，但是，同一个任务不能被多台机器重复执行；

抓取任务有两种情况，scheduleX每隔10min定时取抓取任务执行；运营点击“撤回”、“发布”按钮；

二，执行规则
1，什么是规则？
在哪个地方投放数据？：资源位Code描述（资源位=楼层=Tag）
在什么时间投放数据？：起、止时间
投放什么数据？：选品集处理之后的数据集合
投放形式？：静态录入or赛马排序or个性化

2，规则执行的大致环节
具体参见“rmc_page_schedule.xml”文件，行8-行13。每一个Bean对应类的invoke()方法就是每一个环节的具体执行过程。
准备数据：准备执行链路上的初始化数据。
赛马：根据指标进行排序。
去重：上面楼层已经展现过的数据，下面不再展示。
过滤：各种过滤。具体参见“rmc_page_schedule.xml”文件中bean的配置。
取数据：字段补全。
投出去哪些数据：形成PublishJob。


三，数据投放
将数据写到oss。

=================================================================================================
一个排期真正到指定时刻开始执行的过程：一个排期执行，就是更新一个页面内的数据，一个页面包含一个资源位的列表，每个资源位任意时刻只有一个有效的排期生效。

10，
函数功能：
    scheduleX会定时调用这个方法，去查询数据库中已经要进行的排期
	
public ProcessResult GrubScheduleProcessor.process(LongTimeJobContext context) {
    行119，从数据库中选取合适的页面，随后要发布这个页面所有有效的排期，调用10.1，List<Pair<String,Long>> taskList = selectTasks(bizGroup, DeltaAdminEnv.getEnv(),timeFly);
    行127，执行这个页面的任务，调用，execute(sub, DeltaAdminEnv.getEnv(), bizGroup);
}
-------------------------------------------------------------------------------------------------
10.1，
函数功能：
    从数据库中选取合适的页面，随后要发布这个页面所有的排期
public List<Pair<String,Long>> GrubScheduleProcessor.selectTasks(String bizGroup, String ownSign,Integer timeFly)  {
    行93，数据库中查询合适的页面，以进行排期的发布；数据库用时间戳上行锁，调用10.1.1，list = deltaPagePublishJobDAO.findPageIdByLock(ownSign,bizGroup,timeFly);
	行127，执行任务，发布页面内所有的资源位的数据，调用10.1.2，execute(sub, DeltaAdminEnv.getEnv(), bizGroup);；
}
-------------------------------------------------------------------------------------------------
10.1.1，
函数功能：
    查询没有被加锁的pageId的列表，并对一条pageId记录进行加锁；
	
public List<com.tmall.utcp.core.dto.Pair<String,Long>> DeltaPagePublishJobDAOImpl. findPageIdByLock(String ownSign, String bizGroup, Integer timeFly) throws DAOException {
    行116，用当前时间戳作为版本号；
    行118，查询数据库中没有被加锁的pageId的列表；
    行125，尝试对某个pageId进行加锁操作，调用，int count = executeUpdate("DeltaPagePublishJob.tryAcquireLock", paramMap, route);如果加锁成功，那么，返回成功加锁的pageId；
}
-------------------------------------------------------------------------------------------------
10.1.2，
函数功能：
    
public boolean GrubScheduleProcessor.execute(Pair<String,Long> sub, String ownSign, String bizGroup) throws Exception {
    行335，如果当前线程对pageId加锁之后，其他线程没有对它再次进行加锁，那么{
        行336，发布这个页面所有的资源位的排期，调用10.1.2.1，DefaultResultSupport<String> resultSupport = this.publishPage(sub.first, ownSign, null);
    }
}
-------------------------------------------------------------------------------------------------
10.1.2.1，
函数功能：
    
public DefaultResultSupport<String> GrubScheduleProcessor.publishPage(String pageId, String ownSign, Date executingTime) {
    一，执行规则，生成publishJobList：一个页面包含一个资源位的列表，一个资源位包含一个排期的列表；
	行159，查询每个页面对应的资源位的列表；List<RmcResourceDO> rmcResourceDOList = this.rmcResourceManager.findLbRmcResourceDOByZebraPageId(pageId);
    行166，根据资源位之间的依赖关系，拓扑排序之后，生成一个图；（？？？后面楼层间去重使用）；
    行171-行193，遍历每一个资源位{
	    行173，得到每个资源位的排期的信息；
		行175，得到每个资源位对应的需要执行的排期的列表List<DeltaRuleDO> currentNeedHandlerRuleList = resourceRuleInfo.getCurrentNeedHandlerRuleList();
		行178-行191，遍历currentNeedHandlerRuleList中每一个排期DeltaRuleDO{
		    行183，执行这个rule并得到执行结果，调用10.1.2.1.7，DefaultResultSupport<DeltaPublishJobDO> publishJobResult = processRule(rule, executingTime, resourceRuleInfo);
			行185，执行成功，将执行结果添加到publishJobList里面：publishJobList.add(publishJobResult.getValue());
		}
    }
    二，所有的规则执行完毕之后，对规则执行完毕之后返回的结果的汇总的列表publishJobList进行处理，调用10.1.2.1.8，DefaultResultSupport<String> publishResult = this.publishJobHandler.process(pageId, publishJobList, executingTime);
}

-------------------------------------------------------------------------------------------------
10.1.2.1.7，
函数功能：
    执行一个资源位的一个排期的入口函数
	
public DefaultResultSupport<DeltaPublishJobDO> processRule(DeltaRuleDO rule, Date executingTime, ResourceRuleInfo resourceRuleInfo) throws Exception {
    准备数据，rule->request->hsfRequest->context->context结合ruleJobHandler->执行完成结果放于context里面；
	行293，真正执行rule。RuleJobHandler类里面有一个List<DataHandler> dataValves，依次执行列表中每个valve，有：数据准备valve，赛马排序valve，去重valve，各种过滤valve，生成发布任务valve，调用10.1.2.1.7.1，ruleJobHandler.execute(context);
}
-------------------------------------------------------------------------------------------------
10.1.2.1.8，
函数功能：
    ？？？
public DefaultResultSupport<String> process(String pageId, List<DeltaPublishJobDO> publishJobList, Date executingTime) throws Exception {

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1，
函数功能：
    对一个排期执行一系列操作（赛马排序，去重，各种过滤，重排序，生成PublishJob）的入口函数。
public void RuleJobHandler.execute(Context context) throws Exception {
    行39，遍历List<DataHandler>中每个DataHandler{
        行48，调用基类的handle()，其实就是调用每个子类的invoke()方法，每个子类的invoke()方法，就是一个ruleProcess的环节；dataValve.handle(context);子类列表（10.1.2.1.7.1.1，DataInitDataValve准备数据，10.1.2.1.7.1.2，SortDataValve赛马排序，10.1.2.1.7.1.3，RemoveDuplicateDataValve去重，10.1.2.1.7.1.4，AbstractIllegalFilterDataPipeline各种过滤，10.1.2.1.7.1.5，RePosDataValve字段补全，10.1.2.1.7.1.6，GeneratePublishJobDataValve生成要投出去的数据）；
	}
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.1，
函数功能：
    准备数据；
public void DataInitDataValve.invoke(Context context) throws Exception {
    将相关的数据全都放入context里面；
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2，
函数功能：
    赛马排序的入口函数
	
public void SortDataValve.invoke(Context context) throws Exception {
    行161，判断是否要进行排序，调用10.1.2.1.7.1.2.0,boolean isNeedSort = this.needSort(deltaRule, preDeliveryTime, workflowContext);
    行171，要进行排序的数据源存储在dataset的allData字段里面；
	行178，获取分组规则（按店铺分组，按品牌分组）和排序指标的对象InitialRuleDO；
	行197，从InitialRuleDO中获取排序指标的列表；
    行201，排序指标的列表存储在DefaultSortHandler的List<Order>字段里面；
    行204，具体进行排序操作，调用10.1.2.1.7.1.2.1，dataset.handle("allData", sortHandler);
	行209，进行打散操作；（？？？为什么要进行？怎么进行的？）
    行220，将赛马排序之后的“原始顺序”保存到数据库里面；
    行227，如果前端勾选了“被过滤的数据同分组优先替换”，根据前端设置的展示个数限制，对entity按照分组的指标进行“分主备”的操作，并把每个entity的主备信息保存到数据库中；调用10.1.2.1.7.1.2.2，EntityGroupAndLimtHandler.invoke()；
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.0,
函数功能：
    判断是否要进行重新排序
private Boolean needSort(DeltaRule deltaRule, Date preDeliveryTime, WorkflowContext context) throws Exception {
    如果没有排过序，那么返回true；
	如果是轮播，那么只会排序一次，不进行重排序；
	其他情况，返回context.get("isDeliverNextBatch");字段的内容；
	    
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.1，
函数功能：
    对数据源按照指标进行打分，并按照总分进行快速排序
	
public List<Entity> DefaultSortHandler.invoke(Context context, List<Entity> entityList, Map<String, Object> param) {
    行74，取指标，调用10.1.2.1.7.1.2.1.1，processFetchIndexJob(context, entityList, param);
    行76，只是依据每个商品的得分进行快速排序，调用10.1.2.1.7.1.2.1.2，processSortJob(entityList);

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.2，
函数功能：
    对allData数据集合进行分主备数据的操作，并把每个entity的主备信息保存到数据库中。
	
EntityGroupAndLimtHandler.invoke(){
    行66，给allData每个元素设置主备信息，调用10.1.2.1.7.1.2.2.1，getRuleEntitys(context, entityList, param);
	行75，将每个商品的主备信息（type字段）保存到数据库中；

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.2.1，
函数功能：
    给allData每个元素设置主备信息
public List<DeltaRuleEntitydataDO> EntityGroupAndLimtHandler.getRuleEntitys(Context context, List<Entity> entityList, Map<String, Object> param) throws DAOException {
    limit表示展示个数的限制；
	如果limit没有设置，{
	    那么，allData都设置为主数据；
	} else {
	    定义一个Map<Object, List<Entity>> groupMap，K表示：在这个分类条件之下，allData中总共可以分为几类，V表示：放置这个分类之下的主数据；（例子：allData中10个商品，现在分类标准是按照店铺分类，allData中4个耐克商品和6个阿迪商品，所以，groupMap的K有两个为阿迪和耐克，每个K的V有2个商品）
		从高分到低分依次遍历alldata{
		    将属于同一个分类的商品 && 在limit限制之内的商品标记为主数据；
			其他数据都放入bakData中；
		}
		bakData都标记为备数据；
	}
	
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.1.1，
函数功能：
    商品列表在每一个指标之下打分，结合每个指标的权重，算出每个商品的总分数。
	
private void DefaultSortHandler.processFetchIndexJob(Context context, List<Entity> entityList, Map<String, Object> param) {
    遍历每一个排序的指标{
        行85，补全数据；依据字段的名字和要补充entity的列表，得到这些entity关于这个字段之下的一个“分数”；调用10.1.2.1.7.1.2.1.1.1，
        遍历每一个商品或者店铺{
		    将这个字段之下的分数*此字段的权重，加入到总数中，便于后面进行排序；
        }
    }

}

-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.1.1.1，
函数功能：
    依据一个字段和entity的列表，进行补全字段；
FieldStandardlizelHandler.invoke(){
    行97，输入entityList和name字段的名字，补全entityList的此name字段下的值，调用10.1.2.1.7.1.2.1.1.1.1，DataResolve.invoke(context,entityList,new String[]{name});//entityfield 批量调用
	行101-行111，给每个entity从小到大依次写一个分数；
	行125-行138，如果归一化操作是”对数归一“，那么，{
	    将这个分数区间进行归一化，对数归一？？？
	} else（即：不是对数归一的情况）{
	    将entityList的所有商品的分数归一化到[0.0-100.0]这个区间；
	}
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.1.1.1.1，
函数功能：
    字段补全，入口方法。
DataResolve.invoke(){
    行43，遍历需要补全字段的每个entity{
	    检察这个entity是否已经有field这个字段了，如果已经有了，那么，继续处理下一个entity；
		行49，如果entity没有这个字段，取这个字段的相关的配置信息；FieldConfig fd = FieldFactory.getField(entityType, field);
	}
	行85，取出可以补全这个字段的DataService；
	行88-行102，将要获取此字段值的entity的id全都保存到ids列表里面；
	行115，将要补全的字段的名字写入paramMap里面；例子："_resolvefields_":"itemBrandId"；
    行122，调用对应的service，去查询ids（商品的列表），某个字段之下的每个商品对应的值；调用10.1.2.1.7.1.2.1.1.1.1.1，：Map<String/*entityId*/, Entity/*已经补全好相应字段的entity*/> newEntities = dataService.batchGet(entityType, ids, paramMap, context);
	}
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.1.1.1.1.1，
函数功能：
    对于某个字段，批量获取entity列表的字段内容。入口方法。
public Map<String, Entity> DeltaDataServiceBase.batchGet(String entityType,List<String> ids,Map<String, Object> paramMap,Context cont) throws AdaptException{
    行122，补全entity列表之下的这个字段的数值，其实调用的是子类的getDatas()方法，10.1.2.1.7.1.2.1.1.1.1.1.1，Map<String, Entity> datas = this.getDatas(ids, paramMap);比如，要补全的字段的名字是itemBrandId，那么，调用的子类就是：ItemBrandSpuDataServidce.getDatas()

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.1.1.1.1.1.1，
函数功能：
    获取商品的spuId和brandId信息；
	
ItemBrandSpuDataServidce.getDatas(){
    行53，真正的查询字段数值的过程，调用，itemResultDO = itemQueryServiceClient.queryItemById(LangUtil.getLong(id), queryItemOptionsDO);
	行60-行77，从查询结果中获取需要补全的字段的数值；
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.2.1.2，
函数功能：
    对商品的列表进行快速排序
	
void private DefaultSortHandler.processSortJob(List<Entity> entityList) {
    快速排序；
}

-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.3，
函数功能：
    去重操作入口函数。对主库和备库的商品分别进行去重（去重的含义：上面楼层出现过的东西，下面楼层不能再出现）
	
public void RemoveDuplicateDataValve.invoke(Context context) throws Exception {
    行52，到数据库中，取出对应排期和数据集的主库数据，所有entity的id的列表保存到ids列表；
	行59，从数据库中，将主库数据上次的赛马顺序取出来，赋给对应的entity；调用10.1.2.1.7.1.3.0，mergeEntities(mainIdList, deltaRule.getId(), DeltaRuleEntitydataDO.MAIN_DATA, mainData);
	行61，对主库商品列表进行去重，调用10.1.2.1.7.1.3.1，PageFiltHandler.handle()；

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.3.0，
函数功能：
    从数据库中，将主库数据上次的赛马顺序取出来，赋给对应的entity
	
protected void mergeEntities(List<String> entityIdList, Long ruleId, Byte type, List<Entity> entityList) throws Exception {
    行56，从数据库中，将主库数据上次的赛马顺序取出来，
	行61-行76，将顺序赋给对应的entity；
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.3.1，
函数功能：
    实现全局去重
	
public List<Entity> PageFiltHandler.handle(Context context, List<Entity> inputEntitys, Map<String, Object> param) {
    行61，如果数据集的类型是“其他”，那么，不进行去重操作；
	行67，如果当前排期本身有定投规则（定向地区和人群），不与其他规则进行去重；
	行72-行81，取出当前这个排期资源位依赖的更高级别的资源位的列表；
	行82-行99，取出每个资源位的entity的列表，即，取得高级别的资源位已经执行“去重操作”完成的结果数据；（由于在调度的时候已经能够保证高级别的资源位优先执行完成，而且，分配到同一组机器上面，所以，这里只需要取到当前已经执行完的当前资源位依赖的高级别资源位的数据，作为去重操作的源数据；）
    行101-行110，如果当前资源位（即，楼层）的商品，包含上面楼层已经出现过的商品，那么给这些商品打上一个去重原因的标记（"被页面全局去重"）；
	行112，遍历本排期的数据集，去掉打标记的entity；
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4，
函数功能：
    各种过滤操作的入口函数。（入口：AbstractDataPipeline，会依次执行dataValves）
	
public void AbstractDataPipeline.handle(Context context) throws Exception {
    行58，调用, 10.1.2.1.7.1.4.1，invoke(context)方法;
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.1，

函数功能：
    依次执行DataHandler 中的每个dataValve
	
public void AbstractDataPipeline.invoke(Context context) throws Exception {
    依次执行DataHandler 中的每个dataValve；
	行70，调用10.1.2.1.7.1.4，handle()方法；
	但是这次handle()方法在行58，会调用每个DataHandler.invoke()；例子：调用OnlineFilterDataValve.invoke()方法；
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.2，
函数功能：
    过滤非有效数据(下架商品/被处罚商家)
	
onlineFilterDataValve.invoke(){
    行42，构建筛选条件condition，用于脚本过滤；例子condition="(e.get('REMOVED') != null && e.get('REMOVED'))"；
    行55，实际执行过滤操作，调用10.1.2.1.7.1.4.2.1，doFilter(deltaRule, dataset, condition, LifeCircleEventTypeEnum.ONLINE_FILTER, context);
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.2.1，
函数功能：
    各种Filter都会调用这个doFilter()方法。doFilter()方法根据各种Filter传入的筛选条件condition，从maindata中筛选出符合条件的元素，保存到needFilter列表里面，这个needFilter只在”同分组优先替换“的逻辑中使用，needFilter列表用于记录主数据中哪些元素需要被备用数据去顶替掉。
	
protected void AbstractIllegalFilterDataPipeline.doFilter(DeltaRule deltaRule, DataSet dataset, StringBuffer condition, LifeCircleEventTypeEnum eventType, Context context) throws Exception {
	行120，传入一个筛选条件，根据筛选条件condition，从maindata数据中选择出符合条件的元素；一个例子：condition=(e.get('REMOVED') != null && e.get('REMOVED'))，通过执行groovy脚本的形式，从mainData中得到符合筛选条件的元素列表保存到needFilter中，调用，dataset.select("mainData", "needFilter", Where.get().add(new Script(condition.toString())));
	行122，如果needFilterList不为空{
	    如果勾选了”同分组优先替换“，那么{
		    行128，用同一分组的备数据顶替掉主数据，调用10.1.2.1.7.1.4.2.1.1，ReplaceEntityHandler.invoke();
		} else{
		    行135，主数据中符合筛选条件的直接过滤掉，调用，dataset.filter("mainData", Where.get().add(new Script(condition.toString())));
		}
	}

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.2.1.1，
函数功能：
    勾选”同分组优先替换“，用同一分组的备数据去顶替被过滤掉的主数据；
	
public List<Entity> ReplaceEntityHandler.invoke(Context cont, List<Entity> entityList, Map<String, Object> param) {
    行49-行67，数据准备，取出主数据mainData，备用数据bakData，主数据中需要替换掉的数据列表needReplaceList；
	行69，对备用数据做过滤；
	行74-行88，在主数据对应的位置，直接用某个备用数据，覆盖掉需要替换的主数据。遍历主数据的每一个元素，如果这个元素在needReplaceList里面的话，那么{
	    遍历备用数据每一个元素，{
		    如果备用数据可以顶替主数据元素，那么{
			    备用数据列表中删除这个备用元素；
				在主数据列表中当前这个主数据位置，用备用数据覆盖原来的主数据元素；
			}
		}
	}
	行91，如果(!sameShopReplace)？？？，那么{
	    将经过一番替换的主数据列表依据每个元素的分数进行排序；
	}
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.3，
函数功能：
    过滤不带特定标签的商品/商家

TagsFilterDataValve.invoke(){
    行54-行59，构建筛选条件condition；
	行60，实际执行过滤操作，调用10.1.2.1.7.1.4.2.1，doFilter(deltaRule, dataset, condition, LifeCircleEventTypeEnum.ONLINE_FILTER, context);
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.4，
函数功能：
    是否参加价格申报过滤，当前判断逻辑为判断tmc_tags
	
PriceDeclareFilterDataValve.invoke(){
    行84-行119，构建筛选条件condition；例子：
	condition=( e.get('tmc_tags') == null || !((Set)e.get('tmc_tags')).contains(19577) || ( !((Set)e.get('tmc_tags')).contains(19577) &&  !((Set)e.get('tmc_tags')).contains(96834) &&  !((Set)e.get('tmc_tags')).contains(86018) &&  !((Set)e.get('tmc_tags')).contains(300018132)  ) )&& ( (( e.get('secKillTag') == null || !((String)e.get('secKillTag')).equals("big") ) && ( e.get('tags') == null || (!((Set)e.get('tags')).contains(19577) && !((Set)e.get('tags')).contains(96834) && !((Set)e.get('tags')).contains(86018) &&  !((Set)e.get('tags')).contains(300018132) ) ))&& ( e.get('shopTags') == null || ( !((Set)e.get('shopTags')).contains(35585)  ) ) )

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.5，
函数功能：
    虚假交易商家处罚

FakeTradePunishValve.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.6，
函数功能：
    过滤掉非活动商家

ActivityShopFilterDataValve.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.7，
函数功能：
    过滤非有效数据(重复)

DuplicateFilterDataValve.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.8，
函数功能：

BlackRoomFilterDataValve.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.9，
函数功能：
    过滤非有效数据(下架商品/被处罚商家)

IllegalInstallmentItemFilterValve.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.10，
函数功能：

ItemDiscountDataValue.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.11，
函数功能：

CouponEffectiveFilterDataValve.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.12，
函数功能：

GuiPeiDataValve.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.4.13，
函数功能：

FodderDataFilterValve.invoke(){

}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.5，
函数功能：
    重新确定每个商品的展示位置pos（RePosDataValve）
public void RePosDataValve.invoke(Context context) throws Exception {
    行70,重排主库的数据,使得pos开始的实体为第一个元素,调用10.1.2.1.7.1.5.1,  dataset.handle("mainData", (Handler) ApplicationService.getBean("arrangeByPosHandler"),Params.get().addValue("pos", currrentBeginPos));
}

-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.5.1,
函数功能:
    从主数据中取下一批轮播的数据
public List<Entity> ArrangeByPosHandler.invoke(Context cont, List<Entity> entityList,Map<String, Object> param) {
    行31,pos表示投放开始取数据的位置;
	行41,取出主数据列表;
	行43-行49,找到pos指向的主数据中的位置;
	行51-行54,将0-pos位置的数据移到后面.pos-末尾的数据移到前面;(即:轮播过的数据移到后面,没轮播过的数据移到前面去)
	
}

-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.6，
函数功能：
    产生publishJob(GeneratePublishJobDataValve)
	
public void GeneratePublishJobDataValve.invoke(Context context) throws Exception {
	行110,具体执行,调用10.1.2.1.7.1.6.1，DeltaPublishJobDO publishJob = innerExecute(context);
	
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.6.1，
函数功能：

private DeltaPublishJobDO GeneratePublishJobDataValve.innerExecute(final Context context)  throws Exception{
    行145,调用10.1.2.1.7.1.6.1.1,DeltaPublishJobDO publishJobDO = this.genPublishData(context, entityList, deltaRule);
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.6.1.1,
函数功能：

private DeltaPublishJobDO genPublishData(Context context, List<Entity> entityList, DeltaRuleDO deltaRule) throws DAOException {
    行238，获取这个资源位对应的前端搭建的模块结构和需要哪些字段的相关信息；
    行249，propertiesList是一个map的list，每一个map是一个实体的所有的字段；
	行285，遍历schemaDOList，每一个DeltaResourceRenderSchemaDO（也是DeltaDatasetMetaMappingDO），就是前端需要展示的一个字段的名字，需要后台去填充相应的内容{
	    行294，补全这个K的数据，即V（填充DeltaDatasetMetaMappingDO对象对应的V，到property里面）,调用10.1.2.1.7.1.6.1.1.1，isBreakPipeline = processFetchValue(deltaRule, ruleId, pitOccuppied, curPitPos, cEntity, property, dataMap, schemaDO, metaMappingResultDO, isVideoModule);
	}
    行329，调用invoke()方法, 进入AbstractDataPipeline.invoke(){
        行70，进入KfcFilterDataValve（违禁词过滤）;
    }
    行372，String properties保存了实体对应于前端的模块的需要展示的字段以及补全这些字段的内容，具体例子（[{"_entityType_:0":"ITEM","_id_:0":"565172277338","af_1x1:0":"","brandLogo:0":"//img.alicdn.com/bao/uploaded/i1/TB1qH_yjlyWBuNkSmFPwu0guVXa.png","btnText:0":"","couponUrl:0":"//taoquan.taobao.com/coupon/unify_apply.htm?activityId=e66772b0c91a4e0893af73e11769ca6e&sellerId=3283316151&acm=ak-zebra-13362-28629.1003.1.2518113&scm=1003.1.ak-zebra-13362-28629.ITEM_565172277338_2518113&isCouponNew=1","couponValue:0":5,"hideSalePoint:0":false,"iconImg:0":"","itemActPrice:0":"45","itemActPriceTitle:0":"狂欢价","itemDesc:0":"满90元再减5元","itemImg:0":"//img.alicdn.com/bao/uploaded/i1/TB1RdgorwmTBuNjy1XbSuuMrVXa.jpg","itemMPrice:0":"45","itemTagPrice:0":"158","itemTagPriceTitle:0":"当前价","itemTitle:0":"车载MP3播放器多功能蓝牙","itemUrl:0":"//detail.tmall.com/item.htm?acm=ak-zebra-13362-28629.1003.1.2518113&id=565172277338&scm=1003.1.ak-zebra-13362-28629.ITEM_565172277338_2518113","salePoint:0":""},{"_entityType_:1":"ITEM","_id_:1":"566954660116","af_1x1:1":"","brandLogo:1":"//img.alicdn.com/bao/uploaded/i1/TB1_QNwrER1BeNjy0Fmwu20wVXa.png","btnText:1":"","couponUrl:1":"//taoquan.taobao.com/coupon/unify_apply.htm?activityId=42cf92e25a58432ba86260cf139b7881&sellerId=2457203449&acm=ak-zebra-13362-28629.1003.1.2518113&scm=1003.1.ak-zebra-13362-28629.ITEM_566954660116_2518113&isCouponNew=1","couponValue:1":40,"hideSalePoint:1":false,"iconImg:1":"","itemActPrice:1":"69","itemActPriceTitle:1":"狂欢价","itemDesc:1":"领卷立减3元 2年质保","itemImg:1":"//img.alicdn.com/bao/uploaded/i1/TB1fBNifIUrBKNjSZPxSut00pXa.jpg","itemMPrice:1":"69","itemTagPrice:1":"180","itemTagPriceTitle:1":"当前价","itemTitle:1":"车载mp3播放器汽车音乐","itemUrl:1":"//detail.tmall.com/item.htm?acm=ak-zebra-13362-28629.1003.1.2518113&id=566954660116&scm=1003.1.ak-zebra-13362-28629.ITEM_566954660116_2518113","salePoint:1":""},{"_dataFilter_:2":"1023"},{"_dataFilter_:3":"1023"},{"_dataFilter_:4":"1023"},{"_dataFilter_:5":"1023"},{"_dataFilter_:6":"1023"},{"_dataFilter_:7":"1023"},{"_dataFilter_:8":"1023"},{"_dataFilter_:9":"1023"},{"_dataFilter_:10":"1023"},{"_dataFilter_:11":"1023"},{"_dataFilter_:12":"1023"},{"_dataFilter_:13":"1023"},{"_dataFilter_:14":"1023"},{"_dataFilter_:15":"1023"},{"_dataFilter_:16":"1023"},{"_dataFilter_:17":"1023"},{"_dataFilter_:18":"1023"},{"_dataFilter_:19":"1023"}]）
	
}
-------------------------------------------------------------------------------------------------
10.1.2.1.7.1.6.1.1.1，
private boolean processFetchValue(DeltaRuleDO deltaRule, Long ruleId, List<Integer> pitOccuppied, int curPitPos,Entity cEntity, HashMap<String, Object> property, Map<String, String> dataMap, DeltaResourceRenderSchemaDO schemaDO,DeltaDatasetMetaMappingDO metaMappingResultDO, boolean isVideoModule) throws DAOException {


}

-------------------------------------------------------------------------------------------------









================================================================================================
20180622
注意：

各种过滤的入口函数都是invoke()方法，通过AbstractDataPipeline的invoke()进行依次执行的。

每个FilterDataPipeline的invoke方法只是做筛选条件的准备工作。

每一次实际执行过滤操作，都是在AbstractIllegalFilterDataPipeline的doFilter()方法里面执行的，而且，分为是否勾选了”同分组有限替换“。

流程图代码

@startuml

|AbstractDataPipeline|
start
:invoke()方法中
依次执行
DataHandler
中的每个
dataValve;
|#AntiqueWhite|onlineFilterDataValve|
:构建筛选条件
condition，
用于脚本过滤;
:实际执行过滤操作;
|AbstractIllegalFilterDataPipeline|
:传入一个筛选条件，
根据筛选条件
condition，
从maindata数据中
选择出符合条件
的元素;
:如果勾选了”同分组
优先替换“，那么，
用同一分组的备数据
顶替掉主数据
ReplaceEntityHandler;
:否则，主数据中
符合筛选条件的
直接过滤掉;
|#AntiqueWhite|ReplaceEntityHandler|
:数据准备，取出主数据
mainData，备用
数据bakData，主
数据中需要替换
掉的数据列表
needReplaceList；
:对备用数据做过滤;
:在主数据对应的
位置，直接用某个
备用数据，覆盖掉
需要替换的主数据.
:备用数据列表中
删除这个备用元素;
:如果(!sameShopReplace)，
那么, 将经过一番
替换的主数据列表
依据每个元素的
分数进行排序;
|onlineFilterDataValve|
:返回;

|TagsFilterDataValve|
:过滤不带特定标签
的商品/商家;

|AbstractDataPipeline|
:invoke();

|#AntiqueWhite|PriceDeclareFilterDataValve|
:是否参加价格申报过滤，
当前判断逻辑为判断tmc_tags;
|AbstractDataPipeline|
:invoke();



|FakeTradePunishValve|
:虚假交易商家处罚;
|AbstractDataPipeline|
:invoke();



|#AntiqueWhite|ActivityShopFilterDataValve|
:过滤掉非活动商家;
|AbstractDataPipeline|
:invoke();


|DuplicateFilterDataValve|


|#AntiqueWhite|BlackRoomFilterDataValve|



|CouponEffectiveFilterDataValve|




|#AntiqueWhite|ItemDiscountDataValue|




|IllegalInstallmentItemFilterValve|




|#AntiqueWhite|FodderDataFilterValve|



|GuiPeiDataValve|




stop

@enduml


================================================================================================


